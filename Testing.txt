CS4431 - Project 1

Students: Junyu Zhu & Tianyu Li


*******************
Introduction
*******************

We implemented JUnit tests under test source folder. 
Therefore TA can just run our JUnit test cases one by one to see the result.
Each JUnit cases will include assertEqual functions and print short description.



*******************
Test Task 2.1
*******************
JUnit File: test/TestTask2_1.java
Simple Description: 
After the students table is created, the new buffer manager initialized 12 empty buffers, index from 0 to 11, waiting for inserting values

After inserting 6 records, the last occupied empty buffer id: 7
In other words, buffer 0 ~ 7 have been occupied. 

After inserting another 6 records, the last occupied empty buffer id: 11
In other words, all empty buffers have been occupied.

To sum up, through keep inserting new records into table, we witnessed that all empty buffers/frames have been occupied.



*******************
Test Task 2.2
*******************
JUnit File: test/TestTask2_2.java
Simple Description: 
After the students table is created, initialize a new buffer manager which has 10 empty buffers indexing from 0 to 9, waiting for querying later

After running Query 1, the last occupied empty buffer id: 4
In other words, there are still some empty buffers left.

Query 2 is as the same as Query 1, so it will not require any new buffer while running Query 2
After running Query 2, the last occupied empty buffer id: 4.
In other words, running Query 2 only needs to use existing buffers.

To sum up, we are running two same queries in this test. Since two queries are same, the second query should only need the existing buffers
for itself to run. The result showed that after second query ran, there is no new empty buffers occupied. 
(Since the buffers are not full and empty buffers are there, the replacement policy will not be called.)



*******************
Test Task 2.3 LRU
*******************
JUnit File: test/TestTask2_3_LRU.java
Simple Description: 
After creating the students table and inserting a few records, the buffers showed as following:

NOte: logSequenceNumber works as TimeStamp, since it increases everytime the bufferMgr access the buffer

*** List of buffers (id, logSequenceNumber) ***
id: 0	logSeqNum: 5
id: 1	logSeqNum: 6
id: 2	logSeqNum: 6
id: 3	logSeqNum: 7
id: 4	logSeqNum: 8
id: 5	logSeqNum: 4
id: 6	logSeqNum: 4
id: 7	logSeqNum: 5

*** List of buffers (id, logSequenceNumber) sorted by logSeqNum ***
id: 3	logSeqNum: 3
id: 4	logSeqNum: 3
id: 5	logSeqNum: 4
id: 6	logSeqNum: 4
id: 0	logSeqNum: 5
id: 7	logSeqNum: 5
id: 1	logSeqNum: 6
id: 2	logSeqNum: 6

Then we created a new table, that will need to get buffers for it run. Therefore the LRU replacement policy is implemented here.

*** List of buffers (id, logSequenceNumber) selected by LRU after creating new table ***
id: 3
id: 4


The results here showed that while creating a new table, there are two buffers selected by LRU policy. 
These two buffers had the oldest timestamps (smallest logSequenceNumber). Therefore the LRU policy works.



*******************
Test Task 2.3 CLOCK
*******************
Simple Description: 

The results of this policy are basically same as the one of the origin simpleDB. Thus no testing is implemented for this part. Instead, if
there are any questions about the code for this part, we would like to have a DEMO with TA.


*******************
Original SimpleDB not broken
*******************

In order to make simpleDB not broken, we will running the "CreateStudentDB.java" & "StudentMajor.java" files under "src" folder.
These two files come with the original SimpleDB. If the results of our modified are confirmed as the same as the result of the original
SimpleDB, then we won't break the SimpleDB. The final results showed our modified SimpleDB produced the same result. Therefore the SimpleDB
still works. 

